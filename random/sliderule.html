<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<head>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>alexalemi.com/random/sliderule.html</title>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">
  <style>
    /* Browser reset */
    html {
        box-sizing: border-box;
        line-height: 1.15;
        -webkit-text-size-adjust: 100%;
    }

    body {
      background: #fff;
    }

    svg{
      stroke: #000;
      font-family: "Merriweather", serif;
      position: fixed;
      top: 0;
      bottom: 0;
    }

    .tick{
      stroke-width:1;
      fill:#000;	
    }

    .label {
      font-size: 20px;
      font-weight: 100;
      font-style: italic;
    }

    .minor-label {
      font-size: 14px;
    }

    .special-label {
      font-size: 10px;
    }

    .edge {
      stroke-width:1;
      fill: GhostWhite;
      z-order: -2;
    }

    .indicator {
      stroke-width: 1;
      stroke: firebrick;
      opacity: 0.75;
      z-order: 3;
    }

    /* #hand {
      transition: transform 0.2s ease-in;
    }
    #slide-face {
      transition: transform 0.2s ease-in;
    }
		*/


    .hand {
      stroke-width: 1;
      stroke: firebrick;
      opacity: 0.75;
      z-order: 5;
    }

    .hand-overlay {
      opacity: 100;
      stroke: firebrick;
      fill: firebrick;
      stroke-linecap:round;
      z-order: 6;
    }

    .hand-back {
      stroke-width: 2;
      opacity: 100;
      stroke: firebrick;
      fill: firebrick;
      stroke-linecap:round;
      z-order: 7;
    }

    #main {
      height: 100%;
      width: 100%;
    }

  </style>
</head>
<body>
<script src="https://d3js.org/d3.v6.min.js"></script>
<div id="main"></div>
<script>

const radians = 2 * Math.PI / 360;
  margin = 50,
  radius = 200,
  width = (radius+margin)*2,
  height = (radius+margin)*2,
  originTickLength = 90,
  majorTickLength = 40,
  innerMajorLabelRadius = radius - majorTickLength - 20,
  innerOriginLabelRadius = radius - originTickLength - 5,
  halfTickLength = 0.8 * majorTickLength,
  mediumTickLength = 0.5 * majorTickLength,
  minorTickLength = 0.2 * majorTickLength,
  innerMinorLabelRadius = radius - minorTickLength - 25,
  specialTickLength = majorTickLength * 0.9,
  innerSpecialLabelRadius = radius - mediumTickLength - specialTickLength - 15;
  specialTickPad = 5,
  indicatorLength = 15,
  indicatorBleed = 20,
  handBack = 100,
  handBleed = 10,
  handOverlayRadius = 5;
    

const innerScale = d3.scaleLog()
  .domain([1, 10])
  .range([0, 360])

var innerPosition = 0.0;
var handPosition = 0.0;

function rotate(d, offset) {
  let angle = innerScale(d) + offset;
  return 'rotate(' + angle + ')';
}

function drawClock(){ //create all the clock elements
  const smallerDim = Math.min(window.innerWidth, window.innerHeight);

  var svg = d3.select("#main").append("svg")
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("preserveAspectRatio", "xMidYMid meet");

  var rule = svg.append('g')
    .attr('id','slide-outer')
    .attr('transform','translate(' + (radius + margin) + ',' + (radius + margin) + ')')

  var face = rule.append('g').attr('id', 'slide-face');

	face.append('g').attr('id','face-overlay')
    .append('circle')
    .attr('class', 'edge')
    .attr('x', 0)
    .attr('y', 0)
    .attr('r', radius);

  // Home Tick
  face.selectAll('.origin-tick')
    .data([1]).enter()
    .append('line')
    .attr('class', 'tick origin-tick')
    .attr('x1',0)
    .attr('x2',0)
    .attr('y1',-radius)
    .attr('y2',-radius + originTickLength)
    .attr('transform', d => rotate(d, innerPosition));
	face.selectAll('.origin-label')
		.data([1])
			.enter()
			.append('text')
			.attr('class', 'label major-label')
			.attr('text-anchor','left')
			.text(function(d){ return d; })
      .attr('x', 2)
      .attr('y', -innerOriginLabelRadius)
      .attr('transform', d => rotate(d, innerPosition));
    

  // Major Ticks
  face.selectAll('.major-tick')
    .data(d3.range(2,10)).enter()
    .append('line')
    .attr('class', 'tick major-tick')
    .attr('x1',0)
    .attr('x2',0)
    .attr('y1',-radius)
    .attr('y2',-radius + majorTickLength)
    .attr('transform', d => rotate(d, innerPosition));

  // Major Labels
	face.selectAll('.major-label')
		.data(d3.range(1,10))
			.enter()
			.append('text')
			.attr('class', 'label major-label')
			.attr('text-anchor','middle')
			.text(function(d){ return d; })
      .attr('x', 0)
      .attr('y', -innerMajorLabelRadius)
      .attr('transform', d => rotate(d, innerPosition));

  // Half Ticks
  face.selectAll('.half-tick')
    .data(d3.range(2.5,10.5,1)).enter()
    .append('line')
    .attr('class', 'tick half-tick')
    .attr('x1',0)
    .attr('x2',0)
    .attr('y1',-radius)
    .attr('y2',-radius + halfTickLength)
    .attr('transform', d => rotate(d, innerPosition));

  // Medium Ticks
  face.selectAll('.med-tick')
    .data(d3.range(1.1, 6.0, 0.1)).enter()
    .append('line')
    .attr('class', 'tick medium-tick')
    .attr('x1',0)
    .attr('x2',0)
    .attr('y1',-radius)
    .attr('y2',-radius + mediumTickLength)
    .attr('transform', d => rotate(d, innerPosition));

  // Minor Ticks
  face.selectAll('.minor-tick')
    .data(d3.range(1.025, 2.0, 0.025).concat(d3.range(2.05, 6.0, 0.05)).concat(d3.range(6.1, 10.0, 0.1))).enter()
    .append('line')
    .attr('class', 'tick minor-tick')
    .attr('x1',0)
    .attr('x2',0)
    .attr('y1',-radius)
    .attr('y2',-radius + minorTickLength)
    .attr('transform', d => rotate(d, innerPosition));

  // Minor Labels
  face.selectAll('.minor-labels')
    .data(d3.range(1, 10)).enter()
    .append('text')
    .attr('class', 'label minor-label')
    .attr('text-anchor','middle')
    .text(function(d){
      return d;
    })
    .attr('x', 0)
    .attr('y', -innerMinorLabelRadius)
    .attr('transform', d => rotate(1 + d/10, innerPosition));

  let specialLocs = [Math.PI, Math.E, Math.sqrt(4 / Math.PI), Math.PI / 180, 180 / Math.PI, Math.log(10)]
  let specialLabels = ["Ï€", "e", "c", "Q", "r", "L", "M"]
  // Pi
  face.selectAll('.special-ticks')
    .data(specialLocs).enter()
    .append('line')
    .attr('class', 'tick special-tick')
    .attr('x1', 0)
    .attr('x2', 0)
    .attr('y1', -radius + mediumTickLength + specialTickPad)
    .attr('y2', -radius + mediumTickLength + specialTickLength)
    .attr('transform', d => rotate(d, innerPosition));

  // Pi Label
  face.selectAll('.special-labels')
    .data(specialLocs).enter()
    .append('text')
    .attr('class', 'label special-label')
    .attr('text-anchor','middle')
    .text(function(d, i){ return specialLabels[i]; })
    .attr('x', 0)
    .attr('y', -innerSpecialLabelRadius)
    .attr('transform', d => rotate(d, innerPosition));


  var indicator = rule.append('g')
    .attr('id', 'indicator')
    .append('line')
    .attr('class', 'indicator')
    .attr('x1', 0)
    .attr('x2', 0)
    .attr('y1', -radius - indicatorBleed)
    .attr('y2', -radius + indicatorLength);


  var hand = rule.append('g').attr('id', 'hand')
    
  hand.append('line')
    .attr('class', 'hand')
    .attr('x1', 0)
    .attr('x2', 0)
    .attr('y1', 0)
    .attr('y2', radius + handBleed)

  hand.append('line')
    .attr('class', 'hand hand-back')
    .attr('x1', 0)
    .attr('x2', 0)
    .attr('y1', -handBack)
    .attr('y2', 0);

	rule.append('g').attr('id','hand-overlay')
    .append('circle')
    .attr('class', 'hand hand-overlay')
    .attr('x', 0)
    .attr('y', 0)
    .attr('r', handOverlayRadius);

  return [face,hand];
}

var [face,hand] = drawClock();

face.on('wheel', evt => {
  evt.preventDefault();
  innerPosition += evt.deltaY / 10 / (evt.shiftKey ? 10 : 1);
  handPosition -= evt.deltaY / 10 / (evt.shiftKey ? 10 : 1);
  face.attr('transform', 'rotate(' + innerPosition + ')');
});

var main = document.getElementById('main');

main.onwheel = (evt) => {
  handPosition += evt.deltaY / 10 / (evt.shiftKey ? 10 : 1);
  evt.preventDefault();
  hand.attr('transform', 'rotate(' + handPosition + ')');
};

var ongoingHandTouches = [];
var ongoingFaceTouches = [];

function copyTouch({ identifier, pageX, pageY }) {
  return { identifier, pageX, pageY, handPosition, innerPosition };
}

function ongoingHandTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingHandTouches.length; i++) {
    var id = ongoingHandTouches[i].identifier;
    
    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}
function ongoingFaceTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingFaceTouches.length; i++) {
    var id = ongoingFaceTouches[i].identifier;
    
    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}

function touchScroll(dX, dY, shiftKey) {
	return 0.5 * (dY + dX / 2) / (shiftKey ? 10 : 1);
}

function handHandleStart(evt) {
  evt.preventDefault();
  // console.log('start');
  var touches = evt.changedTouches;

  for (var i=0; i<touches.length; i++) { 
     // console.log("touchstart:" + i + "...");
     ongoingHandTouches.push(copyTouch(touches[i]));
     // console.log("touchstart:" + i + ".");
  }
}

function handHandleMove(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingHandTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let dY = touches[i].pageY - ongoingHandTouches[idx].pageY;
      let dX = touches[i].pageX - ongoingHandTouches[idx].pageX;
			// console.log("dY = " + dY + ", dX = " + dX);
      handPosition = ongoingHandTouches[idx].handPosition + touchScroll(dX, dY, evt.shiftKey); 
      hand.attr('transform', 'rotate(' + handPosition + ')');
    } else {
      // console.log("Can't figure out which touch to continue.");
    }
  }
}

function handHandleEnd(evt) {
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingHandTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      ongoingHandTouches.splice(idx, 1);
    } else {
      // console.log("Can't figure out which touch to end.");
    }
  }
}

function handHandleCancel(evt) {
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingHandTouchIndexById(touches[i].identifier);
    ongoingHandTouches.splice(idx, 1);
  }
}

function faceHandleStart(evt) {
  evt.preventDefault();
  // console.log('start');
  var touches = evt.changedTouches;

  for (var i=0; i<touches.length; i++) { 
     // console.log("touchstart:" + i + "...");
     ongoingFaceTouches.push(copyTouch(touches[i]));
     // console.log("touchstart:" + i + ".");
  }
}

function faceHandleMove(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingFaceTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let dY = touches[i].pageY - ongoingFaceTouches[idx].pageY;
      let dX = touches[i].pageX - ongoingFaceTouches[idx].pageX;
			console.log("dY = " + dY + ", dX = " + dX);
      innerPosition = ongoingFaceTouches[idx].innerPosition + touchScroll(dX, dY, evt.shiftKey); 
      handPosition = ongoingHandTouches[idx].handPosition;
      hand.attr('transform', 'rotate(' + handPosition + ')');
      face.attr('transform', 'rotate(' + innerPosition + ')');
    } else {
      console.log("Can't figure out which touch to continue.");
    }
  }
}

function faceHandleEnd(evt) {
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingFaceTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      ongoingFaceTouches.splice(idx, 1);
    } else {
      console.log("Can't figure out which touch to end.");
    }
  }
}

function faceHandleCancel(evt) {
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingFaceTouchIndexById(touches[i].identifier);
    ongoingFaceTouches.splice(idx, 1);
  }
}


main.addEventListener("touchstart", handHandleStart, false);
main.addEventListener("touchend", handHandleEnd, false);
main.addEventListener("touchcancel", handHandleCancel, false);
main.addEventListener("touchmove", handHandleMove, false);

face.on("touchstart", faceHandleStart, false);
face.on("touchend", faceHandleEnd, false);
face.on("touchcancel", faceHandleCancel, false);
face.on("touchmove", faceHandleMove, false);

</script>
</body>
</html>
